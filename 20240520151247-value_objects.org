:PROPERTIES:
:ID:       F6ABC426-2ADF-405E-821A-6189532066DD
:END:
#+title: Value objects
#+date: 2024-05-20 15:12 PM
#+updated:  2024-05-20 15:46 PM
#+filetags: :ruby:rails:

Sometimes I find myself coding business logic around object's property.
Depending on how much is involved, it might make sense to extract an object that
represents the value to contain that business logic.

I had for example an object with a ~color~ property, whose value is a color hex
code. I wanted to know if the color was considered dark or light, the RGB
representation and if it was the default color all the objects are instantiated
with.

In this case, I created a ColorType value object

#+begin_src ruby
class ColorType
  DEFAULT = 'e4f2fe'.freeze

  attr_reader :hex
  alias hex_color hex

  def initialize(hex = nil)
    @hex = hex.presence || DEFAULT
  end

  def to_rgb
    [r, g, b]
  end

  def r = hex[0..1].to_i(16)
  def g = hex[2..3].to_i(16)
  def b = hex[4..5].to_i(16)

  def darkish?
    to_rgb.sum < (255 * 3) / 3.6
  end

  def default?
    hex == DEFAULT
  end
end
#+end_src

Which I then wrapped around the object's color value (ActiveRecord object in
this case)

#+begin_src  ruby
class Memo < ApplicationRecord
  def color
    ColorType.new(super)
  end
end
#+end_src

Example usage.

#+begin_src ruby
irb(main):001> m = Memo.new
=>
#<Memo:0x0000ffff67460160
...
irb(main):002> m.color
=> #<ColorType:0x0000ffff5fe732e0 @hex="e4f2fe">
irb(main):003> m.color.hex
=> "e4f2fe"
irb(main):004> m.color.to_rgb
=> [228, 242, 254]
irb(main):005> m.color.darkish?
=> false
irb(main):006> m.color.default?
=> true
#+end_src

Why do this? All these methods could just be added to the model, but it kinda
begs for a separate object. Not only for the behavior encapsulation, but
reusability if needed.

We could do more with this. Need equality comparison? That can added:

  #+begin_src ruby
    def ==(other)
      hex == other.hex
    end
  #+end_src
