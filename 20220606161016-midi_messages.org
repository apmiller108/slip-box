:PROPERTIES:
:ID:       5741B4DD-B291-4F6D-A33A-EB4CD83792FF
:END:
#+title: MIDI messages
#+date: 2022-06-06 16:10 PM
#+updated: 2024-11-12 08:56 AM
#+filetags: :audio:midi:

See also [[id:24E1468A-279A-4B44-8AB8-A8A1C5D8D42D][MIDI clock]]

* Channels
  - Each MIDI connections can communicate of 16 channels (0-15)
  - MIDI devices can switch channels they send messages over.
  - Devices listening for message can selectively listen on specific channels,
    or all channels at once.
* Anatomy of a MIDI message
  - MIDI messages are composed of several bytes. Just how many depends on the
    type of messages
  - The first byte is called the ~Status Byte~ and it has two parts, the message
    type and the channel information.
    - Message info is the first four bits
    - Channel info is the four least significant bits
    - The top most bit is always set. This identifies the byte as the one
      containing the message type and channel info (ie, status)
  - The subsequent bytes contain the message data.
    - The top bit is unset.

** Note On example
*** Status Byte (first byte)
   The first byte is the status indicating message type (1001 = 9/Note On) and
   channel (0100 = 4/midi channel 5)
   | Message Type | Channel |
   |--------------+---------|
   | 1 0 0 1      | 0 1 0 0 |

   - Top bit is set
   - Message type: 9 = Note On
   - Channel: 4 (Channel 5)
   - This means the Note On message is in the range of 9..24 (eg, 9 + the
     channel 0 - 15)
*** Bitwise AND
   In order to determine if the status byte is On or Off, we just need to look
   at the first 4 bits. We can mask out the last four bits with a bitwise &
   operator.

   #+begin_src cpp
   if ((statusByte & 0xF0) == 0x90) { // ON message }
   if ((statusByte & 0xF0) == 0x80) { // OFF message }
   #+end_src

   1. ~0xF0~ in binary is 11110000.
   2. The ~&~ operation is performed between these two numbers. For example, if
      the status byte is 10000011 (0x83 in hex, which is a Note Off message on
      channel 4): 10000011 (status) & 11110000 (~0xF0~) is 10000000 (0x80). This
      operation effectively "masks" the lower 4 bits (which represent the
      channel) and keeps only the upper 4 bits (which represent the message
      type). By comparing the result to ~0x80~ or ~0x90~ (10000000 or 10010000),
      this checks for note Off or On, respectively.
*** Data Bytes
   The next two bytes are note and velocity data:
   | Byte            | Value | Data     |
   |-----------------+-------+----------|
   | 0 0 1 1 1 1 0 0 |    60 | Note     |
   | 0 1 1 1 1 1 1 1 |   127 | Velocity |

   - Top bits are unset indicating these are the message values
   - 127 is therefore the maximum value

** Note off
   - One common way is to use the same message type, but with a value of 0
** Hexadecimal Notation
   - Send message bytes using Hex notation, prefixed with ~0x~. For example,
     ~00111100~ (60) is sent as ~0x3c~.
   - See also https://kb.iu.edu/d/afdl
** Midi over USB
  These messages will be 4 bytes. There is an extra header byte that comes first
  which contains the cable and command.
* Tools
** SendMIDI
   https://github.com/gbevin/SendMIDI
   Send MIDI from the command line.
** midisnoop
   https://github.com/surfacepatterns/midisnoop
   Receive and print MIDI messages. Use this in conjunction with sendMIDI to try
   things out. Uses Alsa or JACK midi drivers.
   See also [[id:abbff1aa-b163-4f08-ba2c-c7ed8ca8ef12][Mixxx, Ardour, JACK and MIDI]]
* Sending MIDI notes
** C / C++
   https://ccrma.stanford.edu/~craig/articles/linuxmidi/
*** RtMidi
    https://www.music.mcgill.ca/~gary/rtmidi/
* Midi Jack Wiring
** Midi input
  - https://www.kieranreck.co.uk/MIDI-6N137-vs-6N138-vs-6N139/
** Midi output
  Note the 220ohm resistor is optional and included as a safety precaution
  against connecting miswired cables and whatnot (eg, current flowing into the
  TX pin).
  [[file:images/schematic_midi_out.jpg]]

