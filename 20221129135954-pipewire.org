:PROPERTIES:
:ID:       a0628dc3-e296-43ae-9830-d25fdc33659c
:END:
#+title: pipewire
#+date: 2022-11-29 13:59 PM
#+updated: 2025-08-25 15:52 PM
#+filetags: :linux:audio:

https://docs.pipewire.org/index.html

see also [[id:959acd5a-c6f7-4247-baf6-d8f5c7fd765a][pulseaudio]]

* GUI
  [[https://gitlab.freedesktop.org/rncbc/qpwgraph][qpwgraph]] works just like qjackctl
* Scripting
  See https://docs.pipewire.org/page_man_pw-cli_1.html
  See https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Migrate-JACK
** pw-link
   Manage IO connections. Takes the place of ~jack_connect~, ~jack_disconnect~
   and ~jack_lsp~

   https://docs.pipewire.org/page_man_pw-link_1.html

** Dump midi messages
  https://docs.pipewire.org/page_man_pw-mididump_1.html
* Latency
  See also
  https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Config-PipeWire#setting-buffer-size-quantum

  This can be configured in ~~/.config/pipewire/~. Copy files from
  /usr/share/pipewire

  Applications can be set to use a certain buffer size / sample rate with:

  #+begin_src sh
    # buffer size over sample rate
    PIPEWIRE_QUANTUM=192/48000 Ardour
  #+end_src

  This will determine the latency:

  44.1kHz:

  | Buffer       | Latency |
  |--------------|---------|
  | 32 samples   | 0.73ms  |
  | 64 samples   | 1.45ms  |
  | 128 samples  | 2.9ms   |
  | 256 samples  | 5.8ms   |
  | 512 samples  | 11.6ms  |
  | 1024 samples | 23.2ms  |

  48kHz:

  | Buffer       | Latency |
  |--------------|---------|
  | 32 samples   | 0.67ms  |
  | 64 samples   | 1.3ms   |
  | 128 samples  | 2.7ms   |
  | 256 samples  | 5.3ms   |
  | 512 samples  | 10.67ms |
  | 1024 samples | 21.3ms  |
* Issues
** Volume very low
*** Set volume using a mixer tool
**** alsamixer
   Use ~alsamixer~ tool and set the output gain to whatever.

   - See also https://wiki.archlinux.org/title/PipeWire#Low_volume
   - You can store the alsa config by using ~alsactl~

     #+begin_src shell
     sudo alsactl store
     #+end_src
**** pavucontrol
   Pipewire works with Pulse audio, so pavucontrol should work as well. In fact,
   I had better luck with this to set the volume level my Xone k2
**** amixer
     Like alsamixer, but CLI only (no TUI)
* Multiple sound cards
  By default pipewire handles multiple sound cards timing by resampling. In
  pavucontrol you can set the Pro Audio profile on the card which, amonng other
  things will assume all devices share the same clock.

  https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/FAQ#what-is-the-pro-audio-profile

** Timing
   Instead of letting pipewire handle timing by resampling, which I found to be
   less than perfect, we can use a module-loopback to introduce a delay on one
   or more devices.

   See also [[id:959acd5a-c6f7-4247-baf6-d8f5c7fd765a][pulseaudio]] for how to set that up
* Troubleshooting
  https://support.system76.com/articles/audio/
* Configuration
See also https://github.com/apmiller108/audio
...and
- https://www.reddit.com/r/linux_gaming/comments/1gao420/low_latency_guide_for_linux_using_pipewire/
- https://docs.pipewire.org/page_man_pipewire_conf_5.html
- https://codeberg.org/rtcqs/rtcqs
- https://manual.ardour.org/setting-up-your-system/the-right-computer-system-for-digital-audio/
** wireplumber lua scripts
I used these scripts to configure my audio interfaces.
See also https://github.com/apmiller108/audio/tree/main/config/wireplumber/main.lua.d
** Multiple audio interfaces
Different hardware clocks can create problems. Pipewire will correct for
different clock rates with adaptive resampling. I found this could create audio
problems (eg, pops and clicks) when applying audio processing on the output
streams.

From the [[https://docs.pipewire.org/page_man_pipewire-props_7.html][docs]]:

#+begin_quote
  Source, sinks, capture and playback streams contain a high quality adaptive
  resampler. It uses sinc based resampling with linear interpolation of filter
  banks to perform arbitrary resample factors. The resampler is activated in the
  following cases:

  The hardware of a device node does not support the graph samplerate.
  Resampling will occur from the graph samplerate to the hardware samplerate.
  The hardware clock of a device does not run at the same speed as the graph
  clock and adaptive resampling is required to match the clocks. A stream does
  not have the same samplerate as the graph and needs to be resampled. An
  application wants to activate adaptive resampling in a stream to make it match
  some other clock. PipeWire performs most of the sample conversions and
  resampling in the client (Or in the case of the PulseAudio server, in the
  pipewire-pulse server that creates the streams). This ensures all the
  conversions are offloaded to the clients and the server can deal with one
  single format for performance reasons.
#+end_quote

*** Set the clock.name
  Setting the ~clock.name~ property on the output nodes of both interfaces to the
  same value seemed to fix it for me. By sharing the ~clock.name~ pipewire will
  not apply adaptive resampling.

  #+begin_quote
    The name of the clock. This name is auto generated from the card index and
    stream direction. Devices with the same clock name will not use a resampler to
    align the clocks. This can be used to link devices together with a shared word
    clock.

    In Pro Audio mode, nodes from the same device are assumed to have the same clock
    and no resampling will happen when linked together. So, linking a capture port
    to a playback port will not use any adaptive resampling in Pro Audio mode.

    In Non Pro Audio profile, no such assumption is made and adaptive resampling is
    done in all cases by default. This can also be disabled by setting the same
    clock.name on the nodes.
  #+end_quote
