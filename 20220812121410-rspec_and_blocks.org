:PROPERTIES:
:ID:       E559724D-A7A8-438E-8042-1018DFA34AE3
:END:
#+title: RSpec things
#+date: 2022-08-12 12:14 PM
#+updated: 2023-12-14 11:37 AM
#+filetags: :rspec:ruby:

* Blocks
  How to test this with RSpec?

  #+begin_src ruby
    module Thing
      def self.call
        Foo.call do
          Bar.call
        end
        yield
      end
    end
  #+end_src

** Stubbing
    When stubbing ~Foo.call~, in order for block that contains ~Bar.call~ to be
    called, we need to use ~and_yield~. It can take arguments. See also
    https://www.rubydoc.info/gems/rspec-mocks/RSpec%2FMocks%2FMessageExpectation:and_yield

    #+begin_src ruby
      RSpec.describe Thing do
        before do
          allow(Foo).to receive(:call).and_yield
          allow(Bar).to receive(:call)
        end

        describe '.call' do
          it 'calls Foo' do
            described_class.call
            expect(Foo).to have_received(:call)
          end

          it 'calls Bar' do
            described_class.call
            expect(Bar).to have_received(:call)
          end
        end
      end
    #+end_src

** Expecting
    We can expect the subject under test to yield control by passing a block to
    expect with an argument. The argument itself is a block, captured (~&b~) and
    passed to the method call. See also https://relishapp.com/rspec/rspec-expectations/v/3-11/docs/built-in-matchers/yield-matchers

    #+begin_src ruby
      it 'yields control to a block' do
        expect do |b|
          described_class.call(&b)
        end.to yield_control
      end
    #+end_src

** Custom matchers
   You can pass blocks to custom matchers, but we need to use the ~block_arg~
   method. In this example, the captured block is forwarded to the
   ~assert_turbo_stream~ method.

   ðŸš¨ *Must use curly braces for blocks passed to matchers*
   not only will ~do/end~ not work, it will silently fail.

    #+begin_src ruby
      RSpec::Matchers.define :have_turbo_stream do |action:, target: nil, targets: nil, count: 1|
        match do |_actual|
          assert_turbo_stream(action:, target:, targets:, count:, &block_arg).present?
        end
      end

      it { is_expected.to have_turbo_stream(action: 'foo') { assert_select 'div.bar' } }
    #+end_src
* Method stubs
** ~and_invoke~
   Can be used to stub multiple calls to the same method, which could raise and
   retry see also https://www.rubydoc.info/github/rspec/rspec-mocks/RSpec%2FMocks%2FMessageExpectation:and_invoke
* Advisory Locks
  See also [[id:D111FFA2-4A9D-41F4-87DC-E59F3D6E8564][Database Locks]]

  Example code to test:
  #+begin_src ruby
    def call
      result = MyModel.with_advisory_lock_result('my_lock', timeout_seconds: 0) do
        # do things sensitive to competing consumers
      end
      raise MyError unless result.lock_was_acquired?
    end
  #+end_src

  Test the lock creation and behavior with lock cannot be acquired:

  #+begin_src ruby
    describe '#call' do
      it 'creates an advisory lock' do
        allow(MyModel).to receive(:with_advisory_lock_result).and_call_original
        described_class.new.call
        expect(MyModel).to have_received(:with_advisory_lock_result).with('my_lock', timeout_seconds: 0)
      end

      context 'when an advisory lock cannot be acquired' do
        it 'raises an error' do
          locking_thread = Thread.new do
            MyModel.with_advisory_lock('my_lock') do
              sleep 3 # retain lock for enough time to perform expection below
            end
          end
          sleep 0.5 # Allow time for the Thread to be created and lock acquired before the main thread does

          expect { described_class.call }.to raise_error(described_class::MyError)

          locking_thread.kill # Dispose of the thread after expectation (no need to wait any longer)
        end
      end
    end
  #+end_src
