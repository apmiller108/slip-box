:PROPERTIES:
:ID:       57F3BD52-A75D-433A-A07F-CB1E06875C84
:END:
#+title: Sidekiq stuff
#+date: 2021-11-15 13:14 PM
#+updated: 2022-11-04 14:25 PM
#+filetags: :rails:ruby:

* Starting it up
  ~sidekiq -q default -q foo~

  ~sidekiq --help~ shows you all the startup options.

* Poking around in the console
  See [[https://www.mikeperham.com/2021/04/20/a-tour-of-the-sidekiq-api/][Mike Perham's A Tour of the Sidekiq API post]]. This has most of what I
  need.

** Running a job in the console (when sidekiq isn't running)
   #+begin_src ruby
   job = Sidekiq::Queue.new('somequeue').first
   job.klass.constantize.new.perform(*job.args)
   #+end_src

   A Queue is kind of enumerable. You can convert it
   ~to_a~ and find the job if you need. Otherwise just, ~queue.clear~ to empty
   it out and start over.
** Scheduled jobs
   See also https://www.rubydoc.info/github/mperham/sidekiq/Sidekiq/ScheduledSet
#+begin_src shell
irb(main):001:0> r = Sidekiq::ScheduledSet.new
=> #<Sidekiq::ScheduledSet:0x00000000090f6a50 @name="schedule", @_size=1>
#+end_src

*** Add a scheduled job to the queue
    See also https://www.rubydoc.info/github/mperham/sidekiq/Sidekiq/SortedEntry
    #+begin_src ruby
      r = Sidekiq::ScheduledSet.new
      r.first.add_to_queue
    #+end_src

** Retry Sets
   #+begin_src 
   r = Sidekiq::RetrySet.new
   #+end_src
* Enqueuing in bulk
  See also
  https://www.rubydoc.info/github/mperham/sidekiq/Sidekiq%2FClient:push_bulk

  #+begin_src ruby
  Sidekiq::Client.push_bulk('class' => SomeWorkerClass, 'args' => args)
  #+end_src

  ~args~ is a 2D array.

* Middleware
  https://github.com/mperham/sidekiq/wiki/Middleware

* Unique Jobs (ENT)
  https://github.com/mperham/sidekiq/wiki/Ent-Unique-Jobs

  - Jobs are unique for the duration set OR until the job completes
    successfully.
  - If job retries beyond the specified duration, another job can be pushed.
* Scheduled jobs
  https://github.com/mperham/sidekiq/wiki/Scheduled-Jobs

  Scheduled jobs (including retry queue) are polled around every 5 seconds by
  default.  This can be configured with the ~average_scheduled_poll_interval~
  config property.
* Rate Limiting (ENT)
  https://github.com/mperham/sidekiq/wiki/Ent-Rate-Limiting

  There's several options, here is one example.

** Window Limiting Example
   #+begin_src ruby
     class TestLimiterWorker
       include Sidekiq::Worker
     
       def perform(id)
         # Limit 5 per 1 second window. If limit is reached, job thread will pause
         # (sleep) for 1 second before trying again. If still limited, job will be
         # rescheduled linearly up to 20 times until finally going to retry queue.
         limiter = Sidekiq::Limiter.window('test_limit_worker', 5, :second, wait_timeout: 1)
         limiter.within_limit do
           puts "****** RUNNING THE TestLimiterWorker: at #{Time.current} #{id} ********"
           raise if rand(9).zero? # Simulate some job errors
         end
       end
     end
   #+end_src

* Batches
  https://github.com/mperham/sidekiq/wiki/Batches
  
  Gives you a collection of jobs that can be monitored as a group. And has
  callbacks for success and complete.

  #+attr_html: :width 750
  [[file:images/batches.png]] 

   #+begin_src ruby
     class BatchWorker
       include Sidekiq::Worker
     
       BATCH_DESCRIPTION = 'Test Limiter Batch'
     
       def perform
         batch = Sidekiq::Batch.new
         batch.description = BATCH_DESCRIPTION
         batch.jobs do
           100.times do
             SomeWorker.perform_async
           end
         end
       end
     end
   #+end_src
