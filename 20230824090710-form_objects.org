:PROPERTIES:
:ID:       E7CAC743-E22D-48FC-9922-19081FA8A495
:END:
#+title: Form objects
#+filetags: :rails:ruby:
#+date: 2023-08-24 09:07 AM
#+updated:  2023-09-07 09:56 AM

There's a lot on the internet about form objects in Rails. I think it was first
popularized by Thoughtbot. I've found this pattern useful as clean way to handle
complex or non-standard forms where we're not working with just a single
ActiveRecord object. For example, forms that create or update multiple records
(eg, an alternative to [[http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#method-i-accepts_nested_attributes_for][accepts_nested_attributes_for]]) or forms that need to do
API calls to other services, etc.

This gist of this is that we can leverage various ~ActiveModel~ modules to add
behavior to ruby classes, giving them the familiar ActiveRecord interface.

* ActiveModel Modules
** ~ActiveModel::Model~
   At a minimum, you'll probably want this module. It includes [[http://api.rubyonrails.org/classes/ActiveModel/API.html][ActiveModel::API]]
   which provides among other things:
   1. An ~initializer~ method that takes a hash and assigns the key-value pairs to the
      class' defined ~attr_accessor~
   2. The API needed for interfacing with Action Pack and Action View
   3. Support for declaring validations

   See also http://api.rubyonrails.org/classes/ActiveModel/Model.html

   #+begin_src ruby
     class WidgetForm
       include ActiveModel::Model

       attr_accessor :quantity, :expires_at

       validates :quantity, presence: true

       def submit
         return false if invalid?
         # Do the submitting stuff
       end
     end
   #+end_src

   #+begin_src ruby
     form = WidgetForm.new(quantity: '3', expires_at: '2023-12-31')
     form.quantity # => "3"
     form.expires_at # => "2023-12-31"
   #+end_src

   #+begin_src ruby
     form = WidgetForm.new(expires_at: '2023-12-31')
     form.validate! # => ActiveModel::ValidationError: Validation failed: Quantity can't be blank
   #+end_src

   This gives us the fundamentals for being able to use this form in a
   controller, taking in user provided parameters. Although, we're probably
   going to encounter issues with this naive implementation -- more on this
   below. For now, however, we can implement a controller. The example here is
   for a JSON API. There will be a separate section on using form objects in
   HTML rendered views.

   #+begin_src ruby
     class WidgetsController < ApplicationController
       def create
         form = WidgetForm.new(widget_params)
         if form.submit
           render json: form
         else
           render json: { errors: form.errors.full_messages }
         end
       end

       private

       def widget_params
         params.require(:widget).permit(:quantity, :expires_at)
       end
     end
   #+end_src

   When there are validation errors, the client receives the full validation
   error messages generated by ~ActiveModel::Model~.
   #+begin_src shell
     curl --request POST \
          --url http://localhost:3000/widgets/ \
          --header 'Accept: application/json' \
          --header 'Content-Type: application/json' \
          --data '{
             "widget": {
               "expires_at": "2024-01-01",
               "quantity": null
             }
           }'

     {"errors":["Quantity can't be blank"]}
   #+end_src

   Without validation errors, the JSON dump of the form is returned to the
   client. This isn't the JSON structure we'd ultimately want, but again this is
   the most basic approach we can take. We'll look at options for customizing
   the JSON output below.
   #+begin_src shell
     curl --request POST \
          --url http://localhost:300/widgets/ \
          --header 'Accept: application/json' \
          --header 'Content-Type: application/json' \
          --data '{
             "widget": {
               "expires_at": "2024-01-01",
               "quantity": 1
             }
           }'

     {"attributes":{},"quantity":1,"expires_at":"2024-01-01","validation_context":null,"errors":{}}
   #+end_src
** ~ActiveModel::Attributes~
   This is optional, but quite useful as an alternative to the traditional
   ~attr_accessor~. It allows one to declare type casting and default values. Say
   if you have a date string, and need to cast it to a Date object. There are
   many built in type casts or you can even define your own.

   #+begin_src ruby
     class WidgetForm
       include ActiveModel::Model
       include ActiveModel::Attributes

       attribute :quantity, :integer
       attribute :expires_at, :date
       attribute :active, :boolean, default: true

       validates :quantity, presence: true
     end
   #+end_src

   In this example the string ~'3'~ is cast to ~Integer~ and the expires_at date
   string is cast to a Ruby ~Date~ object.
   #+begin_src ruby
     form = WidgetForm.new(quantity: '3', expires_at: '2023-12-31')
     form.quantity # => 3
     form.expires_at # => Sun, 31 Dec 2023
     form.active # => true
   #+end_src

   See also
   http://api.rubyonrails.org/classes/ActiveModel/Attributes/ClassMethods.html

   This is NOT the [[https://api.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html][ActiveRecord attributes API]] but it works in some of the same
   ways. See also [[id:40FFCDB2-F065-4EDC-9DED-C3007827B470][ActiveRecord]] notes.
*** ~ActiveMode::Type~
    This goes along with ~ActiveModel::Attributes~, specifically the type casting
    declarations. There are many built in types. See also
    https://api.rubyonrails.org/classes/ActiveModel/Type.html

    If the built in types aren't enough, and there are peculiar use cases, and
    we're feeling particularly bold, we can define custom types. Let's say we
    have temperature that could be submitted in either Celsius or Fahrenheit and
    we want to store the values in Kelvin.

    To do this, we define a custom type class that defines a ~cast~ method.
    This method contains the custom logic for doing the conversion from F or C
    to K in the decimal data type.

    #+begin_src ruby
      class Kelvin < ActiveModel::Type::Decimal
        K_BASE = 273.15.to_d

        def cast(value)
          value.upcase!
          temp_in_kelvin = if value.include?('C')
                            value.delete('C').to_d + K_BASE
                          elsif value.include?('F')
                            ((value.delete('F').to_d - 32) * (Rational(5, 9))) + K_BASE
                          end
          super(temp_in_kelvin)
        end
      end
    #+end_src

    Then we register the custom type.

    #+begin_src ruby
      ActiveModel::Type.register(:kelvin, Kelvin)
    #+end_src

    ...And use it as we would one of the built in types

    #+begin_src ruby
      class WidgetForm
        include ActiveModel::Model
        include ActiveModel::Attributes

        attribute :quantity, :integer
        attribute :expires_at, :date
        attribute :active, :boolean, default: true
        attribute :temperature, :kelvin

        validates :quantity, presence: true
      end
    #+end_src

    #+begin_src ruby
      form = WidgetForm.new(temperature: '1 C')
      form.temperature # => 0.27415e3

      form = WidgetForm.new(temperature: '1 f')
      form.temperature # => 0.255927777764e3
    #+end_src

    Doing this does have implications for front ends when displaying the value
    back to the user in their temperature unit preference. For example,
    returning the value in scientific notation in K would be quite unexpected.
    So we'll probably need some custom conversion back to F or C.

    #+begin_src ruby
      class Kelvin < ActiveModel::Type::Decimal
        K_BASE = 273.15.to_d

        def cast(value)
          value.upcase!
          temp_in_kelvin = if value.include?('C')
                            value.delete('C').to_d + K_BASE
                          elsif value.include?('F')
                            ((value.delete('F').to_d - 32) * (Rational(5, 9))) + K_BASE
                          end
          super(temp_in_kelvin)
        end

        def self.to_preferred_unit(value, unit)
          if unit == :celsius
            "#{(value - K_BASE)} C"
          elsif unit == :fahrenheit
            fahrenheit = (((value - K_BASE) * 9) / 5) + 32
            "#{fahrenheit.round(2)} F"
          end
        end
      end
    #+end_src

    #+begin_src ruby
      form = WidgetForm.new(temperature: '15.3 c')
      form.temperature # => 0.28845e3
      Kelvin.to_preferred_unit(form.temperature, :celsius) # => "15.3 C"

      form = WidgetForm.new(temperature: '104.3 f')
      form.temperature # => 0.3133166666666666666988e3
      Kelvin.to_preferred_unit(form.temperature, :fahrenheit) # => "104.3 F"
    #+end_src
