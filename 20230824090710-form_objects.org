:PROPERTIES:
:ID:       E7CAC743-E22D-48FC-9922-19081FA8A495
:END:
#+title: Form objects
#+filetags: :rails:ruby:
#+date: 2023-08-24 09:07 AM
#+updated:  2023-08-31 11:40 AM

There's a lot on the internet about form objects in Rails. I think it was first
popularized by Thoughtbot. I've found this pattern useful as a container for
complex or non-standard forms. For example, forms that create or update multiple
records (eg, an alternative to [[http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#method-i-accepts_nested_attributes_for][accepts_nested_attributes_for]]) or forms that need
to do API calls to other services, etc. Anyway, this is just a quick cheatsheet.

* ActiveModel Modules
** ~ActiveModel::Model~
   At a minimum, you'll probably want this module. It includes [[http://api.rubyonrails.org/classes/ActiveModel/API.html][ActiveModel::API]]
   which provides among other things:
   1. An initializer that takes a hash and assigned the key-value pairs to the
      objects defined attr_accessors
   2. The API needed for interfacing with Action Pack and Action View
   3. Support for declaring validations

   See also http://api.rubyonrails.org/classes/ActiveModel/Model.html

   #+begin_src ruby
     class WidgetForm
       include ActiveModel::Model

       attr_accessor :quantity, :expires_at

       validates :quantity, presence: true
     end
   #+end_src

   #+begin_src ruby
     form = WidgetForm.new(quantity: '3', expires_at: '2023-12-31')
     form.quantity # => "3"
     form.expires_at # => "2023-12-31"
   #+end_src

   #+begin_src ruby
     form = WidgetForm.new(expires_at: '2023-12-31')
     form.validate! # => ActiveModel::ValidationError: Validation failed: Quantity can't be blank
   #+end_src

** ~ActiveModel::Attributes~
   This is optional, but quite useful as an alternative to the traditional
   ~attr_accessor~. It allows one to declare type casting and default values. Say
   if you have a date string, and need to cast it to a Date object. There are
   many built in type casts or you can even define your own.

   #+begin_src ruby
     class WidgetForm
       include ActiveModel::Model
       include ActiveModel::Attributes

       attribute :quantity, :integer
       attribute :expires_at, :date
       attribute :active, :boolean, default: true

       validates :quantity, presence: true
     end
   #+end_src

   In this example the string `'3'` is cast to `Integer` and the expires_at date
   string is cast to a Ruby `Date` object.
   #+begin_src ruby
     form = WidgetForm.new(quantity: '3', expires_at: '2023-12-31')
     form.quantity # => 3
     form.expires_at # => Sun, 31 Dec 2023
     form.active # => true
   #+end_src

   See also
   http://api.rubyonrails.org/classes/ActiveModel/Attributes/ClassMethods.html

   This is NOT the [[https://api.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html][ActiveRecord attributes API]] but it works in some of the same
   ways. See also [[id:40FFCDB2-F065-4EDC-9DED-C3007827B470][ActiveRecord]] notes.
*** ~ActiveMode::Type~
    This goes along with ~ActiveModel::Attributes~, specifically the type casting
    declarations. There are many built in types. See also
    https://api.rubyonrails.org/classes/ActiveModel/Type.html

**** Declaring custom types
     If the built in types aren't enough, and there are peculiar use cases, we
     can define custom types. Let's say we have temperature that could be
     submitted in either Celsius or Fahrenheit and we want to store the values
     in Kelvin.


     To do this, we define a custom type class that defines a `cast` method.
     This method contains the custom logic for doing the conversion from F or C
     to K in the decimal data type.

     #+begin_src ruby
       class Kelvin < ActiveModel::Type::Decimal
         K_BASE = 273.15.to_d

         def cast(value)
           value.upcase!
           temp_in_kelvin = if value.include?('C')
                              value.delete('C').to_d + K_BASE
                            elsif value.include?('F')
                              ((value.delete('F').to_d - 32) * (Rational(5, 9))) + K_BASE
                            end
           super(temp_in_kelvin)
         end
       end
     #+end_src

     Then we register the custom type.

     #+begin_src ruby
       ActiveModel::Type.register(:kelvin, Kelvin)
     #+end_src

     ...And use it as we would one of the built in types

     #+begin_src ruby
       class WidgetForm
         include ActiveModel::Model
         include ActiveModel::Attributes

         attribute :quantity, :integer
         attribute :expires_at, :date
         attribute :active, :boolean, default: true
         attribute :temperature, :kelvin

         validates :quantity, presence: true
       end
     #+end_src

     #+begin_src ruby
       form = WidgetForm.new(temperature: '1 C')
       form.temperature # => 0.27415e3

       form = WidgetForm.new(temperature: '1 f')
       form.temperature # => 0.255927777764e3
     #+end_src
